---
title: 'TP OUMOBIO 4: Utiliser des outils avancés sous R'
author: "Mathieu Brevet"
date: "2024-09-16"
output: 
  pdf_document:
    toc_depth: 4
    includes:
      in_header: preamble.tex
urlcolor: blue
---



```{r setup, include=FALSE}


library(formatR)

knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80, brace.newline = T, args.newline = T), tidy = TRUE, echo=T)




```



Bienvenue dans ce quatrième et dernier TP sur R ! Après avoir vu les principales fonctions et commandes de base sous R nous allons maintenant aborder les commandes et pratiques avancées sur R et Rstudio: la gestion des erreurs, l'utilisation de commandes prédéfinies par d'autres utilisateurs (paquet de fonctions), ainsi que des syntaxes et interfaces R alternatives permettant une meilleure prise en main du code et de ses sorties.



```{r recup data }


data_lezard = read.csv(file = "Suivi_lezard_vivipare.csv")



```




# Gestion des erreurs, avertissements et blocage sous R


Nous allons tout d'abord revenir sur les erreurs et messages d'avertissement dans R. Comme vous avez déjà pu probablement vous en apercevoir, R retourne des messages d'avertissement ou d'erreur en rouge dans la console lorsque vous essayez respectivement de réaliser une action potentiellement erronée ou interdite par la commande/fonction que vous utilisez. Voici des exemples ci-dessous:


```{r exemple message erreur, error=TRUE}



mean(c("a","b","c"))
as.numeric(c("a","b","c"))
# avertissement: création de valeurs manquantes car opérations nécessitant des valeurs numériques


log(-1)
sqrt(-1)
# avertissement: création de valeurs manquantes car opérations interdites, logarithme et racine carré d'une valeur négative (en dehors de l'ensemble de définition de la fonction)





median(data_lezard)
# Erreur: valeurs numériques nécessaires (moyenne sur un tableau de données: aucun sens)

median(data_lizard$SVL_MOTHERS) 
# Erreur: faute de frappe dans le nom de la variable

data_lezard[data$SVL_MOTHERS==65]
# Erreur: sélection sans indiquer sur quels éléments du tableau elle s'opère (ligne, colonne), il faudrait positionner une virgule après la condition pour sélectionner les lignes

data_lezard[,"SVL_MOTHERS"] + data_lezard[,"SEX"]
# Erreur: tentative d'additionner des valeurs numériques et chaînes de caractères





```


Dans le cas où vous n'arrivez pas à déterminer l'origine de l'erreur malgré le message fourni par R, commencez par utiliser la fonction help() pour essayer de voir si vous n'avez pas commis une erreur dans l'utilisation de la fonction. Si cela ne s'applique pas à votre cas (utilisation d'une suite de commande plutôt qu'une fonction prédéfinie) ou si vous n'arrivez pas à trouver l'origine de l'erreur à partir de l'aide, vous pouvez également vous appuyer sur les forums d'entraide (le plus actif étant [stackoverflow](https://stackoverflow.com/), en anglais) ou sur certains sites spécialisés ([ThinkR](https://thinkr.fr/), [STHDA](http://www.sthda.com/french/)).  

Il existe toutefois des cas plus complexe dans lesquels l'erreur ce situe dans un bloc de code contenant de nombreuses fonctions et commandes. Dans ce cas il est très important d'agir séquentiellement, en découpant et testant chaque portion du code utilisé afin d'identifier la source de l'erreur. Voici un exemple concret:


```{r message erreur complexe, error=TRUE}

mode <- function (vect) { # argument de la fonction: vecteur
  names.POSIXlt(                 # récupère le nom sur une variable avec identifiant
    which.max(                   # récupère la (ou les) positions de la valeur maximale
      table(                     # table des effectifs du vecteur
        vect)
      )
    )
}


mode(data_lezard$SEX)


# d'où provient l'erreur ? 

table(data_lezard$SEX)
# ok

which.max(table(data_lezard$SEX))
# ok 

names.POSIXlt(which.max(table(data_lezard$SEX)))
# not ok: l'erreur provient de la fonction names.POSIXlt()

?names.POSIXlt
# il s'agit de la mauvaise fonction ! On a confondu avec la fonction "names()"

```



Il est aussi possible d'avoir recours à l'intelligence artificielle (générative), celle-ci est assez performante quand il s'agit d'interpréter ou d'écrire des lignes de codes tant que l'on reste dans un niveau de complexité raisonnable. Par exemple, reprenez l'exemple ci-dessus et copiez le code correspondant à la fonction (avec l'erreur) dans [ChatGPT](https://chatgpt.com/): l'IA détecte immédiatement l'erreur, vous propose une correction de code, donne une explication de chaque ligne de code et suggère même une voie d'amélioration (pour les vecteurs contenant plusieurs valeurs avec la même fréquence maximale). Dans un cas simple comme celui-ci l'outil se révèle particulièrement efficace !  
Faisons un autre essai, en demandant cette fois-ci de réaliser un code pour une fonction précise, par exemple: "Comment coder sur R un fonction calculant le moment d'ordre de 3 d'une distribution numérique ?". Là encore l'outil fonctionne très bien: il nous donne un rappel de ce qu'est un moment d'ordre 3 et nous propose une fonction R pour calculer cela.  


Il ne faut pas oublier toutefois de garder un esprit critique fort lorsqu'on utilise un outil comme ChatGPT. Si celui-ci est très efficace pour des commandes simples, il peut s'avérer beaucoup plus faillible sur des exemples complexes. Etant entraîné sur des données pré-existantes et étant d'autant plus efficace qu'il a été confronté fréquemment à un cas de figure, il sera forcément sensible à des problèmes nouveaux ou peu étudiés. Il peut également être difficile de l'utiliser sur des cas concrets, car cet outil n'est pas construit pour saisir toutes les spécificités de votre jeu de données et pourrait manquer certaines informations clés. Enfin, sur des problèmes complexes, l'outil a tendance à s'appuyer fortement sur les fonctions créés par d'autres utilisateurs (paquets) et a le défaut d'appeler parfois un grand nombre de dépendance pouvant générer des conflits mais aussi un moindre contrôle sur les actions effectués par le code.  

Il convient donc d'utiliser ce genre d'outil avec certaines bonnes pratiques: il faut leur donner des consignes claires et précises, si possible génériques (en évitant d'utiliser des dénominations propre à notre cas particulier), toujours bien relire et vérifier ligne par ligne le code qui est donné, rester critique sur ses propositions en se demandant s'il n'y a pas des alternatives plus efficaces ou plus simple et lisible, et bien sûr ne pas hésitez à pointer les erreurs que celui-ci réalise (en se basant sur d'autres ressources techniques comme l'aide incluse dans R ou les forums/sites spécialisés).


:::: {.greybox_red data-latex=""}

**POUR ALLER PLUS LOIN**  
\newline
Il existe d'autres IA génératives pouvant aider aux analyses statistiques sous R comme Copilot développé par Github, R wizard pour de la suggestion de code sur R, voire même "Data Analyst" qui vous permet de gérer des analyses complexes en utilisant directement votre jeu de données. Ce dernier outil est à utiliser avec beaucoup de prudence, car si ChatGPT est très performant pour écrire du code, il l'est beaucoup moins pour construire un fil d'analyse statistique logique. Attention également à ne jamais fournir des données sensibles à ce genre d'outil gratuit car vos données seront très probablement récupérées. Ces outils ne sont toutefois pas, pour la plupart, en libre accès et s'utilise souvent via des licences payantes.
::::



:::: {.whitebox data-latex=""}

**EXERCICE**  

  * Vous pouvez trouver ci-dessous un portion de code contenant de nombreuses erreurs, identifiez ces erreurs et corrigez-les. Expliquez ce que réalise ce code.
  
cat_taille = as.character(SVL_IND)  

table(cattaille)  

barplot(cat_taille,   
        main = "Nombres d'individus par valeurs de taille",  
        xlab = "Tailles mesurées",  
        ylab = "Nombres d'individus"  
  )  

rm(cat_taille)  




summary(data_lezard[!dplicated(data_lezard$ID_MOTHERS), M_MOTHERS])  


hist(  
  data_lezard[!duplicated(data_lezard\$ID_MOTHERS)]$M_MOTHERS,  
  main = "Nombres de mères par classe de masse (histogramme)",  
  xlab = "Masse corporelle (g)",  
  ylab = "Effectifs  
  )  

boxplot(  
    data_lezard[!duplicated(data_lezard\$ID_MOTHERS),]$M_MOTHERS,  
    main == "Distribution des masses corporelles des mères (boxplot)"  
    ylab = "Masse corporelle (g)"  
)
  
::::




```{r correction exercice 1, eval=FALSE}

cat_taille = as.character(data_lezard$SVL_IND)

table(cat_taille)

barplot(table(cat_taille), 
        main = "Nombres d'individus par valeurs de taille",
        xlab = "Tailles mesurées",
        ylab = "Nombres d'individus"
  )

rm(cat_taille)




summary(data_lezard[!duplicated(data_lezard$ID_MOTHERS), "M_MOTHERS"])


hist(
  data_lezard[!duplicated(data_lezard$ID_MOTHERS),]$M_MOTHERS,
  main = "Nombres de mères par classe de masse (histogramme)",
  xlab = "Masse corporelle (g)",
  ylab = "Effectifs"
  )

boxplot(
    data_lezard[!duplicated(data_lezard$ID_MOTHERS),]$M_MOTHERS,
    main = "Distribution des masses corporelles des mères (boxplot)",
    ylab = "Masse corporelle (g)"
)



# Ce code permet de décrire la distribution des classes de taille et de la masse des mères parmi les individus étudiés, numériquement (table des effectifs / résumé statistique de la distribution continue) et graphiquement (diagramme en barres / histogramme et boxplot) 

```


# Utiliser des paquets développés par d'autres utilisateurs


## Qu'est-ce qu'un paquet / librairie ?


Comme nous l'avons abordé à la section précédente vous êtes loin d'être seul à travailler sur R. Il en résulte donc que lorsque vous devez créer une fonction donnée il y a une forte probabilité pour que quelqu'un l'ait déjà fait avant vous (sauf si vous abordez un sujet à la pointe des bio-statistiques). Dans de nombreux cas les utilisateurs de R ayant créé ces nouvelles fonctions peuvent les rendre accessible au reste de la communauté en créant un paquet (ou "package" en anglais), composé d'un ensemble de fonction thématique. Ce paquet peut être chargé dans R sous la forme d'une librairie ("library" en anglais) qui vous permettra d'avoir accès à toutes les fonctions contenues dans le paquet.  

Prenons un exemple concret avec les fonctions calculant les coefficient d'asymétrie et d'aplatissement, que nous avions créés dans le second TP. Si on fait une recherche à propos de l'existence de telles fonctions sur R, on trouve rapidement l'existence d'un paquet nommé "EnvStats" qui définit ces fonctions. À travers cet exemple nous allons voir comment charger un paquet dans R et comment l'utiliser:

```{r moments 1, eval=FALSE}
 
install.packages("EnvStats")
# installation du paquet "EnvStats" (toujours indiquer le nom du paquet entre guillemet pour l'installation)
# Rq: cette commande est à utiliser une unique fois sur votre ordinateur, par la suite  l'installation est conservé sur votre ordinateur (par contre la librairie doit être chargée à chaque fois que vous rouvrez une session R)

```

```{r moments 2}

library(EnvStats)
# chargement du paquet sur votre session R


# NB : il est fortement conseillé de regrouper le chargement des librairies au même endroit dans votre code, en préambule (au même endroit que là où vous définissez vos fonctions récurrentes), pour une meilleure lisibilité des dépendances associées à votre code




?kurtosis
?skewness
# aide des fonctions calculant les coefficients de Fisher d'aplatissement et d'asymétrie



kurtosis(data_lezard[!duplicated(data_lezard$ID_MOTHERS),]$M_MOTHERS)
skewness(data_lezard[!duplicated(data_lezard$ID_MOTHERS),]$M_MOTHERS)
# légèrement différents que ce que nous obtenions car ici utilisation d'estimateurs "'biaisés" (voir aide)



```



L'exemple de ce paquet de fonction est intéressant car il illustre aussi le risque associé au chargement d'un paquet de fonction. Un message d'avertissement s'est affiché lorsque vous avez chargé la librairie "EnvStats" dans votre environnement R. Celui-ci indique que certaines fonctions de cette librairie ont le même nom que des fonctions de base contenues dans R. Ces fonctions sont alors masqués par celle que vous venez de charger en utilisant la librairie. Il faut être extrêmement prudent avec cela car on peut ainsi se retrouver à utiliser la mauvaise fonction !  
Voici comment gérer ce type de cas:


```{r masquage,eval=FALSE}

# utilisation de la dernière fonction définie avec le nom "predict" (donc celle de la librairie):
predict(x)


# utilisation de la fonction contenue dans l'environnement de base R:
stats::predict(x)
# on indique avant le nom de fonction le paquet duquel elle provient, et on sépare le nom du paquet et de la fonction par "::"

# utilisation de la fonction contenue dans le package:
EnvStats::predict(x)


# NB: quand il existe dans votre code un conflit sur un nom de fonction et que vous utilisez une de ces fonctions dans votre code, il faut TOUJOURS indiquer le paquet utilisé (comme réalisé sur les deux lignes de code précédentes) 

```



:::: {.greybox_red data-latex=""}

**POUR ALLER PLUS LOIN**  
\newline
Les paquets "officiels" produits sur R sont tous déposés sur l'archive CRAN (Comprehensive R Archive Network) de R. Un manuel de référence est alors associé à chaque package et peut facilement être retrouvé en ligne, avec parfois également des vignettes explicatives sur le fonctionnement du package (pas obligatoire et relativement rare). Il arrive toutefois que des packages soient produits en dehors des archives R (soit parce qu'ils sont en développement, soit parce qu'ils ne satisfont pas tous les prérequis nécessaire pour être enregistré dans l'archive officielle), notamment dans les dépôts tels que R-Forge, RForge ou directement sur le GitHub des développeurs.
::::






## Un exemple de paquet avancé: la syntaxe dplyr et les graphiques ggplot


Certains paquets de fonction sont particulièrement utile et sont devenus très communément utilisé par les biostatisticiens. Nous allons aborder ici en particulier le package introduisant une nouvelle syntaxe pour la manipulation de données "dplyr" et le package proposant un nouveau mode de production graphique "ggplot2", appartenant tous les deux à une collection de packages visant à simplifier les analyses de données sous R: le tidyverse.  

Le tidyverse est une façon très particulière d'aborder R, il vise en effet à remplacer toutes les fonctions usuelles de R par de nouvelles et change complètement la syntaxe d'écriture du code R. L'idée est de fournir un mode d'écriture du code plus facilement lisible et plus intuitif pour des néophytes. Cela a des avantages pour un premier apprentissage mais aussi des inconvénients: il vous sera moins aisé de switcher vers un autre langage de programmation depuis la syntaxe (très) particulière du tidyverse, et ces changements se font au prix d'une faible perte d'efficacité (lorsque l'on compare par exemple les fonctions "purrr" à celles de la famille "apply", ou en général pour toutes les commandes du tidyverse par rapport à des syntaxes créées pour gagner en efficacité comme celle du package "data.table"). Une autre critique majeure est que l'accumulation des différentes syntaxes utilisées par le tidyverse (et potentiellement d'autres syntaxes) ne rend pas forcément le code plus simple à parcourir.  

La syntaxe utilisé par dplyr se base principalement sur le "pipe". Cette manière d'écrire permet d'implémenter une commande comme une succession de fonction que l'on applique à l'objet initial, modifié à chaque étape jusqu'au rendu final. Pour séparer ces différentes étapes on utilise la commande "%>%" dans dplyr. Les principales fonctions de dplyr sont les suivantes:  


```{r dplyr 1, eval=FALSE}

install.packages("dplyr")
```

```{r dplyr 2}

library(dplyr)

data_lezard %>% # choix de la variable de travail (ici notre jeu de données)
  select(SVL_IND, M_IND, POP) %>% # sélection des colonnes d'intérêt
  filter(SVL_IND > 20) %>% # filtre du tableau restant suivant une condition donnée
  mutate(corpulence = SVL_IND / M_IND) %>% # création d'une nouvelle variable égale à
  #la corpulence
  group_by(POP) %>% # partitionnement du tableau par population
  summarise(mean_corpulence = mean(corpulence)) # application de la fonction "mean" à
  #chaque groupe de population



# équivalence en langage R:

by(data_lezard[data_lezard$SVL_IND > 20, c("SVL_IND", "M_IND")],
   data_lezard[data_lezard$SVL_IND > 20, ]$POP,
   function(x) mean(x$SVL_IND / x$M_IND)
)




```



Le cas de ggplot est un peu plus particulier: même sans utiliser le tidyverse l'utilisation de ce mode de visualisation graphique est devenu quasiment incontournable du fait de la qualité des sorties graphiques qu'il propose et de la relative simplicité pour les produire. Vous pouvez trouver ci dessous un mémo sur les différentes commandes possibles d'utiliser grâce à ce paquet:


```{r ggplot cheat sheet, echo=FALSE, fig.cap="Ecriture fichier Mardown", out.width = '100%', fig.pos="H"}
knitr::include_graphics("~/ATER PAU 2024/Cours modifiés/OUMOBIOS/Images/data-visualization.pdf")

```


Prenons quelques exemples à partir des sorties graphiques les plus centrales que nous avons abordées au cours des derniers TP:


```{r ggplot 1, eval=FALSE}

install.packages("ggplot2")
```

```{r ggplot 2}

library(ggplot2)


ggplot(data = data_lezard, aes(POP)) + # indication du jeu de données d'étude,
  # puis de la variable d'intérêt
  geom_bar() +  # type de graphique
  labs(title = "Répartition des individus dans les populations",
       x = "Population", y = "Nombre d'individus") # légendes



ggplot(data = data_lezard, aes(y = M_IND)) + #positionnement de la variable d'intérêt sur
  # l'axe des ordonnées
  geom_boxplot() +
  labs(title = "Distribution de la masse des individus", y = "Masse corporelle (g)")


ggplot(data = data_lezard, aes(M_IND)) + 
    geom_histogram(binwidth = 0.02) + # largeur des classes d'histogramme
    labs(title = "Histogramme de la masse des individus",
         x = "Masse corporelle (g)", y = "Nombre d'individus")





ggplot(data = data_lezard, aes(POP, fill = SEX)) + # couleur de remplissage définie par le sexe
  geom_bar(position = "dodge") + # positionnement des barres les unes à côtés des autres
  labs(title = "Répartition des individus dans les populations, par sexe",
       x = "Population", y = "Nombre d'individus", fill = "Sexe des individus")



ggplot(data = data_lezard, aes(x = SEX, y = M_IND)) + 
  geom_boxplot() +
  labs(title = "Distribution de la masse des individus, par sexe",
       x = "Sexe des individus", y = "Masse corporelle (g)")



ggplot(data = data_lezard, aes(x = SVL_IND, y = M_IND)) + 
    geom_jitter(height = 0.002, width = 0.2) + # marge de déplacement aléatoire des points
    labs(title = "Masse des individus en fonction de leur taille",
         x = "Taille corporelle (mm)", y = "Masse corporelle (g)")







# Exemple de manipulation avancée (combinaison graphiques):


ggplot(data = data_lezard, aes(x = SEX, y = M_IND, colour = SEX)) + 
    geom_violin() +     # ajout de violin plot (courbe de densité)
    geom_boxplot(width = 0.1) + # la visualisation combine boxplot et graphe de densité
    labs(title = "Distribution de la masse des individus, par sexe",
         x = "Sexe des individus", y = "Masse corporelle (g)")




```




:::: {.greybox_red data-latex=""}

**POUR ALLER PLUS LOIN**  
\newline
L'utilisation du tidyverse est avant tout un choix pratique dépendant de chaque utilisateur et de son propre confort, un choix pour lequel il ne faut pas oublier de soupeser les avantages et inconvénients. Toutefois, il est important de noter que ce n'est plus tout à fait le langage R qui est utilisé avec le tidyverse. À ce sujet, il est bon de faire remarquer qu'il n'est pas impossible qu'à terme l'environnement Rstudio/tidyverse (gérés par le même directeur de projet: Hadley Wickham) s'éloigne de l'environnement R pour former une structure à part.
::::



:::: {.whitebox data-latex=""}

**MISE EN APPLICATION**  
\newline
  
Reprenez les graphiques produits au cours des TPs en utilisant les outils ggplot.
  
::::


# Automatiser la production de rapports ou productions scientifiques à partir de R (Markdown)


Il est également possible d'utiliser Rstudio pour produire des rapports directement avec le langage R. Pour cela on utilise un format Markdown qui est un langage de balisage (permet de faire du traitement de texte, en indiquant le formatage des caractères à l'aide de commandes spécifiques). Le code R est encapsulé dans des "chunks" à l'intérieur de ce fichier. Une fois le document réalisé on peut le compiler (en format HTML, pdf ou word) pour obtenir un document finalisé avec les sorties (graphiques ou non) affichées en dessous de chaque ligne de code. Cela permet de produire des rapports code en main de manière très rapide: par exemple tous les polys de TP ont été créés de cette manière !

Voici ci-dessous le chemin à suivre pour créer un fichier Markdown:


```{r markdown 1, echo=FALSE, fig.cap="Création fichier Mardown", out.width = '100%', fig.pos="H"}
knitr::include_graphics("~/ATER PAU 2024/Cours modifiés/OUMOBIOS/Images/Markdown_open.png")
knitr::include_graphics("~/ATER PAU 2024/Cours modifiés/OUMOBIOS/Images/Markdown_dialogue.png")

```

La mise en forme est ensuite gérée comme suit:

```{r markdown 2, echo=FALSE, fig.cap="Ecriture fichier Mardown", out.width = '100%', fig.pos="H"}
knitr::include_graphics("~/ATER PAU 2024/Cours modifiés/OUMOBIOS/Images/Markdown_fichier.png")

```

Une fois votre document produit vous pouvez le compiler pour obtenir un fichier du format souhaité (attention si vous souhaitez produire un fichier pdf la compilation se fera sous l'environnement LaTeX, il faut donc que vous installiez MikteX sur votre ordinateur avant de lancer la compilation):

```{r markdown 3, echo=FALSE, fig.cap="Compilation fichier Mardown", out.width = '100%', fig.pos="H"}
knitr::include_graphics("~/ATER PAU 2024/Cours modifiés/OUMOBIOS/Images/Markdown_compilation.png")

```






:::: {.whitebox data-latex=""}

**MISE EN APPLICATION**  
\newline
  
En utilisant une portion de votre code utilisée dans les précédents TPs, essayer de créer un rapport en R Markdown.
  
::::



# Bilan


# Révisions















